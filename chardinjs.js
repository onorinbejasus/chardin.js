// Generated by CoffeeScript 2.2.2
(function() {

  /* Take from https://stackoverflow.com/questions/5996005/how-to-use-element-offsetparent-with-html-svg-elements*/
  function getBoundingBoxInArbitrarySpace(element,mat){
    let svgRoot = element.ownerSVGElement;
    let bbox = element.getBBox();

    let cPt1 =  svgRoot.createSVGPoint();
    cPt1.x = bbox.x;
    cPt1.y = bbox.y;
    cPt1 = cPt1.matrixTransform(mat);

    // repeat for other corner points and the new bbox is
    // simply the minX/minY  to maxX/maxY of the four points.
    let cPt2 = svgRoot.createSVGPoint();
    cPt2.x = bbox.x + bbox.width;
    cPt2.y = bbox.y;
    cPt2 = cPt2.matrixTransform(mat);

    let cPt3 = svgRoot.createSVGPoint();
    cPt3.x = bbox.x;
    cPt3.y = bbox.y + bbox.height;
    cPt3 = cPt3.matrixTransform(mat);

    let cPt4 = svgRoot.createSVGPoint();
    cPt4.x = bbox.x + bbox.width;
    cPt4.y = bbox.y + bbox.height;
    cPt4 = cPt4.matrixTransform(mat);

    let points = [cPt1,cPt2,cPt3,cPt4];

    //find minX,minY,maxX,maxY
    let minX=Number.MAX_VALUE;
    let minY=Number.MAX_VALUE;
    let maxX=0, maxY=0;
    for(i=0;i<points.length;i++)
    {
      if (points[i].x < minX)
      {
        minX = points[i].x
      }
      if (points[i].y < minY)
      {
        minY = points[i].y
      }
      if (points[i].x > maxX)
      {
        maxX = points[i].x
      }
      if (points[i].y > maxY)
      {
        maxY = points[i].y
      }
    }

    //instantiate new object that is like an SVGRect
    let newBBox = {"x":minX,"y":minY,"width":maxX-minX,"height":maxY-minY}
    return newBBox;
  }

  (function($, window) {
    // Define the plugin class
    let chardinJs = class chardinJs {
      constructor(el) {
        this.data_attribute = 'data-intro';
        this.chardinCssClasses = ["chardinjs-helper-layer", "chardinjs-show-element", "chardinjs-relative-position"];
        this.$el = $(el);
        $(window).resize(() => {
          return this.refresh();
        });
      }

      start() {
        let el, i, len, ref;
        if (this._overlay_visible()) {
          return false;
        }
        this._add_overlay_layer();
        ref = this.$el.find('*[' + this.data_attribute + ']:visible');
        for (i = 0, len = ref.length; i < len; i++) {
          el = ref[i];
          this._show_element(el);
        }
        return this.$el.trigger('chardinJs:start');
      }

      toggle() {
        return (!this._overlay_visible()) ? this.start() : this.stop();
      }

      refresh() {
        let el, i, len, ref, results;
        if (this._overlay_visible()) {
          ref = this.$el.find('*[' + this.data_attribute + ']:visible');
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            el = ref[i];
            results.push(this._position_helper_layer(el));
          }
          return results;
        } else {
          return this;
        }
      }

      stop() {
        let css, i, len, ref;
        this.$el.find(".chardinjs-overlay").fadeOut(function() {
          return $(this).remove();
        });

        this.$el.find('.chardinjs-helper-layer').remove();
        ref = this.chardinCssClasses;

        for (i = 0, len = ref.length; i < len; i++) {
          css = ref[i];
          this._remove_classes(css);
        }

        if (window.removeEventListener) {
          window.removeEventListener("keydown", this._onKeyDown, true);
        }
        else {
          if (document.detachEvent) {
            //IE
            document.detachEvent("onkeydown", this._onKeyDown);
          }
        }
        return this.$el.trigger('chardinJs:stop');
      }

      _remove_classes(css) {
        return this.$el.find('.' + css).removeClass(css);
      }

      set_data_attribute(attribute) {
        return this.data_attribute = attribute;
      }

      _overlay_visible() {
        return this.$el.find('.chardinjs-overlay').length !== 0;
      }

      _add_overlay_layer() {
        let element_position, overlay_layer, styleText;
        if (this._overlay_visible()) {
          return false;
        }
        overlay_layer = document.createElement("div");
        styleText = "";
        overlay_layer.className = "chardinjs-overlay";

        //check if the target element is body, we should calculate the size of overlay layer in a better way
        if (this.$el.prop('tagName') === "BODY") {
          styleText += "top: 0;bottom: 0; left: 0;right: 0;position: fixed;";
          overlay_layer.setAttribute("style", styleText);
        }
        else {
          element_position = this._get_offset(this.$el.get()[0]);
          if (element_position) {
            styleText += "width: " + element_position.width + "px; height:" + element_position.height + "px; top:" + element_position.top + "px;left: " + element_position.left + "px;";
            overlay_layer.setAttribute("style", styleText);
          }
        }

        this.$el.get()[0].appendChild(overlay_layer);
        overlay_layer.onclick = () => {
          return this.stop();
        };

        setTimeout(function() {
          styleText += "opacity: .8;opacity: .8;-ms-filter: 'progid:DXImageTransform.Microsoft.Alpha(Opacity=80)';filter: alpha(opacity=80);";
          return overlay_layer.setAttribute("style", styleText);
        }, 10);
      }

      _get_position(element) {
        return element.getAttribute('data-position') || 'bottom';
      }

      _get_css_attribute(element) {
        let css, cssClasses, i, len, value;
        value = element.getAttribute(this.data_attribute + "-css") || '';
        if (value && String(value).replace(/\s/g, "").length > 1) {
          cssClasses = (value.split(" ")).filter(function(css) {
            return css.length !== 0;
          });
          for (i = 0, len = cssClasses.length; i < len; i++) {
            css = cssClasses[i];
            this._add_css_attribute(css);
          }
        }
        return value;
      }

      _add_css_attribute(css) {
        if (!$.inArray(css, this.chardinCssClasses) > -1) {
          return this.chardinCssClasses.push(css);
        }
      }

      _getStyle(el, styleProp, special) {
        if (window.getComputedStyle) {
          return window.getComputedStyle(el, special).getPropertyValue(styleProp);
        }
        else {
          return el.currentStyle[styleProp];
        }
      }

      _place_tooltip(element, tooltip_layer) {
        let my_height, offset, position, target_element_position, target_height, target_width, tooltipActualWidth, tooltipMaxWidth, tooltip_layer_position;
        tooltip_layer_position = this._get_offset(tooltip_layer);
        //reset the old style
        tooltip_layer.style.top = null;
        tooltip_layer.style.right = null;
        tooltip_layer.style.bottom = null;
        tooltip_layer.style.left = null;
        position = this._get_position(element);
        switch (position) {
          case "top":
          case "bottom":
            target_element_position = this._get_offset(element);
            target_width = target_element_position.width;
            tooltip_layer.style.left = `${(target_width / 2) - (tooltip_layer_position.width / 2)}px`;
            return tooltip_layer.style[position] = "-" + tooltip_layer_position.height + "px";
          case "left":
          case "right":
            tooltipMaxWidth = parseFloat(this._getStyle(tooltip_layer, "max-width"));
            tooltip_layer.style[position] = "-" + tooltipMaxWidth + "px";
            target_element_position = this._get_offset(element);
            target_height = target_element_position.height;
            my_height = parseFloat(this._getStyle(tooltip_layer, "height"));
            tooltip_layer.style.top = `${(target_height / 2) - (my_height / 2)}px`;
            tooltipActualWidth = parseFloat(this._getStyle(tooltip_layer, "width"));
            offset = 175 - (tooltipMaxWidth - tooltipActualWidth);
            return tooltip_layer.style[position] = "-" + offset + "px";
        }
      }

      _position_helper_layer(element) {
        let element_position, helper_layer;
        helper_layer = $(element).data('helper_layer');
        element_position = this._get_offset(element);
        return helper_layer.setAttribute("style", `width: ${element_position.width}px; height:${element_position.height}px; top:${element_position.top}px; left: ${element_position.left}px;`);
      }

      _show_element(element) {
        let current_element_position, helper_layer, tooltip_layer, prev_className;
        helper_layer = document.createElement("div");
        tooltip_layer = document.createElement("div");
        $(element).data('helper_layer', helper_layer).data('tooltip_layer', tooltip_layer);

        if (element.id) {
          helper_layer.setAttribute("data-id", element.id);
        }

        helper_layer.className = `chardinjs-helper-layer chardinjs-${this._get_position(element)}`;
        this._position_helper_layer(element);
        this.$el.get()[0].appendChild(helper_layer);
        tooltip_layer.className = `chardinjs-tooltip chardinjs-${this._get_position(element)}`;
        tooltip_layer.innerHTML = `<div class='chardinjs-tooltiptext'>${element.getAttribute(this.data_attribute)}</div>`;
        helper_layer.appendChild(tooltip_layer);
        this._place_tooltip(element, tooltip_layer);

        prev_className = element.getAttribute("class");
        element.setAttribute("class", prev_className + " chardinjs-show-element " + this._get_css_attribute(element));

        current_element_position = "";
        if (element.currentStyle) { //IE
          current_element_position = element.currentStyle["position"];
        }
        else {
          if (document.defaultView && document.defaultView.getComputedStyle) {
            //Firefox
            current_element_position = document.defaultView.getComputedStyle(element, null).getPropertyValue("position");
          }
        }

        current_element_position = current_element_position.toLowerCase();
        if (current_element_position !== "absolute" && current_element_position !== "relative") {
          prev_className = element.getAttribute("class");
          element.setAttribute("class", prev_className + " chardinjs-show-element");
          // return element.className += " chardinjs-relative-position";
        }
      }

      _get_offset(element) {
        let bBox, element_position;

        if(element instanceof SVGElement){
          bBox = getBoundingBoxInArbitrarySpace(element,element.getScreenCTM())
        }
        else {
          bBox = element.getBoundingClientRect();
        }

        /* Assign the positioning based on the bounding box*/
        element_position = {
          width: bBox.width,
          height: bBox.height,
          top: bBox.y,
          left: bBox.x
        };

        return element_position;
      }

    };
    return $.fn.extend({
      chardinJs: function(option, ...args) {
        let $this, data;
        $this = $(this[0]);
        data = $this.data('chardinJs');
        if (!data) {
          $this.data('chardinJs', (data = new chardinJs(this, option)));
        }
        if (typeof option === 'string') {
          data[option].apply(data, args);
        }
        else if (typeof option === 'object') {
          if (typeof option['attribute'] === 'string') {
            data.set_data_attribute(option['attribute']);
          }
          if (typeof option['method'] === 'string') {
            data[option['method']].apply(data, args);
          }
        }
        return data;
      }
    });
  })(window.jQuery, window);

}).call(this);
